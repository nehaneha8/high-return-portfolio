{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 164,
   "metadata": {},
   "outputs": [],
   "source": [
    "from IPython.display import display, Math, Latex\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import numpy_financial as npf  \n",
    "import yfinance as yf          \n",
    "import matplotlib.pyplot as plt\n",
    "from datetime import datetime , timezone "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Group Assignment\n",
    "### Team Number: 09\n",
    "### Team Member Names: Nicholas Kamakshi Neha\n",
    "### Team Strategy Chosen: Risky"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Reads in the given CSV file, and adds the tickers from the CSV to a list.\n",
    "\n",
    "tickers = pd.read_csv('Tickers.csv', header=None)\n",
    "all_ticker_list = tickers[0].tolist()\n",
    "all_ticker_list = list(set(all_ticker_list))\n",
    "\n",
    "specific_date = datetime.strptime('2023-11-25', '%Y-%m-%d')\n",
    "specific_date = specific_date.replace (tzinfo = timezone.utc)\n",
    "\n",
    "ticker_list = []\n",
    "\n",
    "# Filters out the invalid stocks from the CSV file\n",
    "def valid_ticker(all_ticker_list):\n",
    "    \n",
    "    global ticker_list\n",
    "\n",
    "    # Loops through all of the tickers from the CSV file, and adds them to ticker_list if it's valid.\n",
    "    for ticker in all_ticker_list:     \n",
    "        try:\n",
    "\n",
    "            # Creates a stock object using ticker and finds its currency using YFinance.\n",
    "            stock = yf.Ticker(ticker)\n",
    "            currency = stock.fast_info.currency\n",
    "\n",
    "            # Checks if the ticker is a stock ticker, if it has an average monthly volume of atleast 150,000\n",
    "            # shares, and if it's traded in USD or CAD.\n",
    "            if (isinstance(stock, yf.Ticker) and (currency == 'USD' or currency == 'CAD')# currency? exchange?\n",
    "                and valid_months(stock)):\n",
    "\n",
    "                # If the stock is valid, it's added to the final stock list.\n",
    "                ticker_list.append(stock)\n",
    "\n",
    "\n",
    "        # If the ticker gives any errors (invalid ticker, not a ticker, etc.), an error is thrown and the\n",
    "        # code continues.\n",
    "        except Exception as e:\n",
    "            pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To filter out the valid tickers from the CSV file, we had to check if 3 main things held true for each stock before adding them to our list of valid stocks. We removed an repeated stocks before the code ran to filter the ticker list. \n",
    "1. If the stock object of the ticker is the same type as a yf.Ticker object\n",
    "2. If the currency of the stock is either USD or CAD\n",
    "3. If all of the months from Jan 1st and Oct 31st with 18 or more trading days have average monthly volumes of 150,000 shares \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 166,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[yfinance.Ticker object <MRK>,\n",
       " yfinance.Ticker object <UPS>,\n",
       " yfinance.Ticker object <T.TO>,\n",
       " yfinance.Ticker object <UNP>,\n",
       " yfinance.Ticker object <AXP>,\n",
       " yfinance.Ticker object <TXN>,\n",
       " yfinance.Ticker object <PM>,\n",
       " yfinance.Ticker object <KO>,\n",
       " yfinance.Ticker object <USB>,\n",
       " yfinance.Ticker object <AIG>,\n",
       " yfinance.Ticker object <C>,\n",
       " yfinance.Ticker object <PEP>,\n",
       " yfinance.Ticker object <ABBV>,\n",
       " yfinance.Ticker object <BIIB>,\n",
       " yfinance.Ticker object <AMZN>,\n",
       " yfinance.Ticker object <BMY>,\n",
       " yfinance.Ticker object <PYPL>,\n",
       " yfinance.Ticker object <TD.TO>,\n",
       " yfinance.Ticker object <BLK>,\n",
       " yfinance.Ticker object <CL>,\n",
       " yfinance.Ticker object <ACN>,\n",
       " yfinance.Ticker object <CAT>,\n",
       " yfinance.Ticker object <AAPL>,\n",
       " yfinance.Ticker object <MO>,\n",
       " yfinance.Ticker object <RY.TO>,\n",
       " yfinance.Ticker object <LMT>,\n",
       " yfinance.Ticker object <BK>,\n",
       " yfinance.Ticker object <LLY>,\n",
       " yfinance.Ticker object <PG>,\n",
       " yfinance.Ticker object <QCOM>,\n",
       " yfinance.Ticker object <UNH>,\n",
       " yfinance.Ticker object <BAC>,\n",
       " yfinance.Ticker object <PFE>,\n",
       " yfinance.Ticker object <ABT>,\n",
       " yfinance.Ticker object <BA>,\n",
       " yfinance.Ticker object <SHOP.TO>]"
      ]
     },
     "execution_count": 166,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Returns false if the stock has one or more months with 18 or more trading days and an\n",
    "# average monthly volume of less than 150000\n",
    "def valid_months(stock):\n",
    "\n",
    "    # Sets variables for total monthly volume and number of months - to be used to find average monthly volume.\n",
    "    total_monthly_volume = 0\n",
    "    total_months = 0\n",
    "\n",
    "\n",
    "    # Loops through each month, Jan 1st - Oct 31st 2023\n",
    "    for month in range (1,11): \n",
    "        \n",
    "        try:\n",
    "\n",
    "            # Decides the month ending day based on the month\n",
    "            if month in [1, 3, 5, 7, 8, 10]:\n",
    "                start_month = f'2023-{month}-01'\n",
    "                end_month = f'2023-{month}-31'\n",
    "            elif month in [4, 6, 9, 11]:\n",
    "                start_month = f'2023-{month}-01'\n",
    "                end_month = f'2023-{month}-30'\n",
    "            else:\n",
    "                start_month = f'2023-{month}-01'\n",
    "                end_month = f'2023-{month}-28'\n",
    "\n",
    "\n",
    "            # Gets the stock history for the month\n",
    "            stock_hist = stock.history(start=start_month, end=end_month)\n",
    "\n",
    "            # Gets the average monthly volume of the stock\n",
    "            avg_volume = stock_hist['Volume'].mean()\n",
    "\n",
    "\n",
    "            # If the month has less than 18 trading days, the month is ignored.\n",
    "            if (len(stock_hist) < 18):\n",
    "                pass\n",
    "\n",
    "            # If the month has 18 or more trading days, that months average volume traded is added to the overall\n",
    "            # volume traded total, and the number of months we are considering is incremented by 1.\n",
    "            else:\n",
    "                total_monthly_volume += avg_volume\n",
    "                total_months += 1\n",
    "                \n",
    "        except Exception as e:\n",
    "            pass\n",
    "            \n",
    "        \n",
    "\n",
    "\n",
    "    # Finds the total monthly average, and returns false if it's less than 150,000 shares, and true otherwise.\n",
    "    monthly_avg = total_monthly_volume/total_months\n",
    "    if monthly_avg < 150000:\n",
    "        return False\n",
    "\n",
    "    return True\n",
    "\n",
    "valid_ticker(all_ticker_list)\n",
    "ticker_list"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Uses the global ticker_list initially created with a list of valid stocks (list of ticker objects)\n",
    "- The function iterates over each ticker in the ticker list and fetches the historical data over the last month\n",
    "- Using the historical data it calculates the percent change of the close prices from the Close Prices Series extracted from the Hist Dataframe \n",
    "- Then computes the standard deviation over this series of the percent changes and compares each value to the max_std variable which is used to hold the current highest standard deviaytion \n",
    "- If it is higher than max_std the new value becomes max_std and risky_stock becomes the current ticker object \n",
    "- At the end of the loop the function returns the riskiest stock which is the stock from the original list that has the highest standard deviation \n",
    "- This becomes the stock we use later in the covariance function to choose the rest of the stocks because we want to choose stocks most correlated with the riskiest/hioghest deviation stock"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 167,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "yfinance.Ticker object <SHOP.TO>"
      ]
     },
     "execution_count": 167,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Finds the stock with the highest st. dev over the month before we invest\n",
    "def highest_std():\n",
    "    \n",
    "    global ticker_list #references the list of valid ticker objects \n",
    "    \n",
    "    # Sets a variable to keep track of the max st. dev.\n",
    "    max_std = 0 \n",
    "    \n",
    "    # Set risky stock to first in the list to start \n",
    "    risky_stock = ticker_list[0] \n",
    "\n",
    "    \n",
    "    # Loops through all of the valid tickers. \n",
    "    for ticker in ticker_list:\n",
    "        \n",
    "        # Gets the history and prices of the stock from the last month before investing. \n",
    "        hist = ticker.history(period=\"1mo\")\n",
    "        prices = hist['Close'].pct_change() \n",
    "\n",
    "        \n",
    "        # Finds the st. dev of the stock on the percent change \n",
    "        std = np.std(prices)\n",
    "\n",
    "        \n",
    "        # Compares the stocks st. dev with the current max st. dev. If the st. dev is higher than the current\n",
    "        # st. dev, the stock becomes the new riskiest stock.\n",
    "        if std > max_std: \n",
    "            max_std = std \n",
    "            risky_stock = ticker \n",
    "\n",
    "            \n",
    "    # Removes the riskiest stock from the list of ticker objects.\n",
    "    ticker_list.remove(risky_stock)\n",
    "\n",
    "    # Returns the riskiest stock.\n",
    "    return risky_stock \n",
    "\n",
    "\n",
    "# Sets the riskiest stock to a variable to be used later on.\n",
    "risky_stock = highest_std()\n",
    "risky_stock"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Find_stocks_with_highest_beta uses the filtered list of stocks and the riskiest stocks, previously determined by valid_ticker and highest_std to build the rest of the portfolio. Since we wanted the riskiest portfolio, we tried to reduce diversification, so we only wanted to have 10 stocks in our portfolio. This means this function needs to find 9 stocks, that behave similarly to the given stock. This function begins by making a data frame of every stock's daily percent changes. It does this with data over the past year, because we want to see stocks' daily trends, and a year will give us a large enough sample size to make the beta calculation meaningful. We make a portfolio of all the stocks that we are currently using. Then we calculated the beta of every remaining stock's daily percent changes, with the portfolio's daily percent changes. It then adds the stock with the highest beta to the portfolio and removes it from the list of stocks that we are testing. It repeats the loop 9 times to generate 9 stocks. The reason for using beta is that beta calculates the relationship between a stock and the total market returns. By setting the portfolio as the market, it calculates how related the stock is to the stocks we have already decided to add to our portfolio. Beta, unlike correlation, takes into account the magnitude of how related they are. This means that if 2 stocks fluctuate in the same ways as the portfolio, the stock with more extreme fluctuations will have a higher beta. \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[yfinance.Ticker object <SHOP.TO>,\n",
       " yfinance.Ticker object <PYPL>,\n",
       " yfinance.Ticker object <BMY>,\n",
       " yfinance.Ticker object <QCOM>,\n",
       " yfinance.Ticker object <AXP>,\n",
       " yfinance.Ticker object <USB>,\n",
       " yfinance.Ticker object <BAC>,\n",
       " yfinance.Ticker object <BLK>,\n",
       " yfinance.Ticker object <CAT>,\n",
       " yfinance.Ticker object <C>]"
      ]
     },
     "execution_count": 168,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "series_ticker_list = pd.Series(ticker_list)\n",
    "\n",
    "def find_stocks_with_highest_beta ():\n",
    "    global series_ticker_list\n",
    "\n",
    "    every_stocks_close_prices = pd.DataFrame()\n",
    "    #Define constants\n",
    "    beta_start_date ='2022-11-16'\n",
    "    beta_end_date ='2023-11-23'\n",
    "\n",
    "\n",
    "    #make DF of all the stock close prices\n",
    "    for i in range (len(ticker_list)):\n",
    "        stock_i_info = series_ticker_list[i].history(start=beta_start_date,end=beta_end_date,interval='1d')\n",
    "        stock_i_close = pd.Series(dtype='float64')\n",
    "        stock_i_close = stock_i_info.Close \n",
    "        every_stocks_close_prices[series_ticker_list[i]] = stock_i_close\n",
    "\n",
    "    #make pct_change dataframe , with all the daily pct changes of each stock\n",
    "    price_pct_chance_df = pd.DataFrame()\n",
    "    for i in range ((len(series_ticker_list))):\n",
    "        price_pct_chance_df[i+1] = (100* (every_stocks_close_prices[series_ticker_list[i]]).pct_change())\n",
    "\n",
    "    #remove the first row, since it was nan\n",
    "    price_pct_chance_df=price_pct_chance_df.drop('2022-11-16 00:00:00-05:00')\n",
    "\n",
    "    #get the info for the riskiest stock to make initial portfolio\n",
    "    best_stock_info = risky_stock.history(start=beta_start_date,end=beta_end_date,interval='1d')\n",
    "    stock_1_closes = pd.Series (best_stock_info.Close)\n",
    "    stock_1_pct_change = (100 * stock_1_closes.pct_change())\n",
    "\n",
    "    portfolio_for_beta=pd.DataFrame()\n",
    "    portfolio_for_beta[0]=stock_1_pct_change\n",
    "\n",
    "\n",
    "\n",
    "    #define starting values needed to calculate beta, these numbers are based off the best stock\n",
    "    portfolio_pct_change = stock_1_pct_change\n",
    "    portfolio_pct_change = portfolio_pct_change.drop('2022-11-16 00:00:00-05:00')\n",
    "    portfolio_var = np.var(portfolio_pct_change)\n",
    "\n",
    "    #this this will collect the stock tickers when they are the best in the loop, so we can keep track\n",
    "    top_stock_list=[]\n",
    "\n",
    "    #We want 10 stocks in the portfolio, so this will always be set to 10.\n",
    "    num_of_stocks_in_port = 10\n",
    "\n",
    "    #we go through this loop 9 times to find the best 9 stocks for our purpose \n",
    "    for k in range (num_of_stocks_in_port-1):\n",
    "\n",
    "        #reset all constants\n",
    "        max_beta = -100000\n",
    "        best_stock = -5\n",
    "\n",
    "        #this loop is going through each stock, checking its beta with the portfolio.\n",
    "        #when it is done, it will take the best stock out and add it to top_stock_list\n",
    "        for i in range ((len(series_ticker_list))):\n",
    "\n",
    "\n",
    "\n",
    "            #calculates the current stocks covariance with the portfolio\n",
    "            cur_stock_pct_change = price_pct_chance_df.iloc[:,i]\n",
    "            cur_covar = np.cov(cur_stock_pct_change, portfolio_pct_change)\n",
    "            #covar returns a matix, so I need [1,0] to get the actual ammount\n",
    "            cur_covar = cur_covar[1,0]\n",
    "\n",
    "            #calculates the stocks beta with the portfolio as the market\n",
    "            cur_beta = (cur_covar/portfolio_var)\n",
    "            #print(series_ticker_list[i])\n",
    "\n",
    "\n",
    "            #if the current stock is the highest beta, make it the new max\n",
    "            if (max_beta < cur_beta):\n",
    "                max_beta = cur_beta\n",
    "                #print(cur_stock_pct_change)\n",
    "                best_stock = i \n",
    "\n",
    "                \n",
    "        # we now have the most correlated stock now we need to remove it,and add it to the potfolio\n",
    "\n",
    "        #make the new portfolio with the old stock, and the new stock added to it\n",
    "        portfolio_for_beta[k]=price_pct_chance_df.iloc[:,best_stock]\n",
    "\n",
    "\n",
    "        #rename k as a meaningful name, so code is more readable\n",
    "        num_of_stocks_in_portfolio = k\n",
    "\n",
    "        #makes a new colum that is the average daily percent change of all the stocks we have added\n",
    "        portfolio_for_beta['Row_Sum'] = ((portfolio_for_beta.sum(axis=1))/num_of_stocks_in_portfolio)\n",
    "\n",
    "        portfolio_pct_change = pd.Series(portfolio_for_beta['Row_Sum'])\n",
    "        portfolio_pct_change = portfolio_pct_change.drop('2022-11-16 00:00:00-05:00')\n",
    "\n",
    "       \n",
    "        #since there were was only one item in the portfolio\n",
    "        if ( num_of_stocks_in_portfolio <= 1):\n",
    "            portfolio_pct_change = stock_1_pct_change\n",
    "            portfolio_pct_change = portfolio_pct_change.drop('2022-11-16 00:00:00-05:00')\n",
    "            \n",
    "        # if it is not the first time, \n",
    "        portfolio_var = np.var(portfolio_pct_change)\n",
    "        portfolio_for_beta.drop(['Row_Sum'], axis=1, inplace=True)\n",
    "\n",
    "\n",
    "        #recreate portfolio variation with the new stock added \n",
    "        portfolio_for_beta[k]=price_pct_chance_df.iloc[:,(best_stock)]\n",
    "\n",
    "        #add the stock name to a list so that we can use it outside of this section of code\n",
    "        top_stock_list.append(series_ticker_list[(best_stock)])\n",
    "\n",
    "        #remove the stock from the list of stocks to test\n",
    "        drop_value_df = 1+best_stock\n",
    "        series_ticker_list = series_ticker_list.drop(index=((best_stock)))\n",
    "        series_ticker_list = series_ticker_list.reset_index(drop=True)\n",
    "\n",
    "        #remove the stock from the datafram of all the daily percent changes \n",
    "        price_pct_chance_df = price_pct_chance_df.drop(((best_stock)),axis=1)\n",
    "        price_pct_chance_df.columns = range(price_pct_chance_df.shape[1])\n",
    "\n",
    "\n",
    "        #repeat the process until we have enough stocks \n",
    "\n",
    "\n",
    "\n",
    "    top_stock_list.insert(0, risky_stock)\n",
    "    return (top_stock_list)\n",
    "\n",
    "final_stocks = find_stocks_with_highest_beta()\n",
    "final_stocks"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "[yfinance.Ticker object <AY>,\n",
    " yfinance.Ticker object <TD>,\n",
    " yfinance.Ticker object <SHOP>,\n",
    " yfinance.Ticker object <BCE>,\n",
    " yfinance.Ticker object <RY>,\n",
    " yfinance.Ticker object <L>,\n",
    " yfinance.Ticker object <CNQ>,\n",
    " yfinance.Ticker object <ENB>,\n",
    " yfinance.Ticker object <SAP>,\n",
    " yfinance.Ticker object <BMO>]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Before starting the assignment, we discussed what the optimal weightings would likely be to create the riskiest portfolio possible. Since we had already decided that having the least amount of stocks (10) is what our strategy would be, we could decide the weighting using 10 stocks.\n",
    "Since our 10 stocks are comprised of .. \n",
    "- The 1st stock is the stock with the highest std\n",
    "- The 2nd stock has the highest covariance in relation to the 1st stock. \n",
    "- The 3rd stock has the highest covariance in relation to the 1st and 2nd stock.\n",
    "- And so on for 7 stocks\n",
    "\n",
    "… we knew the riskiest stocks would be at the beginning of our portfolio, and they should have the heaviest weight in our portfolio. \n",
    "After doing some quick math, we found that the following weightings gave the riskiest stocks the heaviest weight while abiding by the min weight rule.\n",
    "- 3 stocks at 20% 20% 20%, 1 stock at 10%, 6 stocks at 5% \n",
    "- 5 at 15% , 5 at 5%\n",
    "- 4 at 17.5%, 6 at 5%\n",
    "\n",
    "These weightings all gave high concentration on the riskiest stocks, but still invests in the other riskiest stocks. \n",
    "To decide which of these weighings we would use for our final portfolio, we used two functions test_weightings and calculate_portfolio_return to test these 3 weighting structures and calculate the portfolio’s return after a week on 20 test csv files we made. (This was simply written for testing purpose to strengthen our strategy and is not called when the final code is run).\n",
    "When we tested them all, it turned out that 16/20 of the csv files gave that the 1st weighting structure gave the highest difference from the starting portfolio value in a week, so we decided to use that for our final portfolio weighting. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 169,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # This is tester code that we used to help determine the final weighting of our portfolio.\n",
    "# def test_weightings():\n",
    "#     global final_stocks\n",
    "#     start_date = '2023-11-14'\n",
    "#     end_date = '2023-11-21'\n",
    "    \n",
    "#     # Initialize an empty DataFrame to store the results\n",
    "#     prices_df = pd.DataFrame(columns=['Stock', 'Start_Price', 'End_Price'])\n",
    "#     for stock in final_stocks:\n",
    "#         # Get the historical prices for the specified period\n",
    "#         hist = stock.history(start=start_date, end=end_date)\n",
    "#         # Extract the closest available prices to the start and end dates\n",
    "#         start_price = hist.loc[:start_date, 'Close'].iloc[-1]\n",
    "#         end_price = hist.loc[:end_date, 'Close'].iloc[-1]\n",
    "#         # Create a temporary DataFrame for the current stock\n",
    "#         temp_df = pd.DataFrame({'Stock': [stock.ticker], 'Start_Price': [start_price], 'End_Price': [end_price]})\n",
    "#         # Use concat instead of append\n",
    "#         prices_df = pd.concat([prices_df, temp_df], ignore_index=True)\n",
    "    \n",
    "#     return prices_df\n",
    "\n",
    "# # Assuming final_stocks is a list of yfinance Ticker objects\n",
    "# # For example: final_stocks = [yf.Ticker(\"AAPL\"), yf.Ticker(\"MSFT\"), ...]\n",
    "# result_df = test_weightings()\n",
    "# result_df\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 170,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # This is tester code that we used to determine the final weighting of our portfolio.\n",
    "# def calculate_portfolio_return(result_df):\n",
    "#     initial_investment = 750000\n",
    "#     weights1 = [0.20, 0.20, 0.20, 0.10, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05] \n",
    "#     weights2 = [0.15, 0.15, 0.15, 0.15, 0.15, 0.05, 0.05, 0.05, 0.05, 0.05]\n",
    "#     weights3 = [0.175, 0.175, 0.175, 0.175, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05] \n",
    "\n",
    "#   # Initialize lists to store calculated values\n",
    "#     investment_per_stock = []\n",
    "#     shares_bought = []\n",
    "#     end_values = []\n",
    "\n",
    "#   # Calculate investment per stock\n",
    "#     for weight in weights3:\n",
    "#         investment = initial_investment * weight\n",
    "#         investment_per_stock.append(investment)\n",
    "\n",
    "#   # Calculate shares bought and end values for each stock\n",
    "#     for i in range(len(result_df)):\n",
    "#         shares = investment_per_stock[i] / result_df.loc[i, 'Start_Price']\n",
    "#         end_value = shares * result_df.loc[i, 'End_Price']\n",
    "#         shares_bought.append(shares)\n",
    "#         end_values.append(end_value)\n",
    "\n",
    "#   # Add calculated data to the DataFrame\n",
    "#     result_df['Shares_Bought'] = shares_bought\n",
    "#     result_df['End_Value'] = end_values\n",
    "\n",
    "#   # Calculate total end value and portfolio return\n",
    "#     total_end_value = sum(end_values)\n",
    "#     portfolio_return = total_end_value - initial_investment\n",
    "\n",
    "#     return total_end_value, portfolio_return\n",
    "\n",
    "# # Example usage:\n",
    "# total_value, portfolio_return = calculate_portfolio_return(result_df)\n",
    "# print(\"Total Value of Portfolio on November 21: \", total_value)\n",
    "# print(\"Portfolio Return: \", portfolio_return)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 171,
   "metadata": {},
   "outputs": [],
   "source": [
    "flat_rate = 4.95 #transaction fee\n",
    "\n",
    "#takes in the list of 10 ticker objects in the order we want them in the portfolio \n",
    "def add_to_final_portfolio(ticker_objects): \n",
    "    \n",
    "    # Accounts for the transaction fee of trading 10 stocks.\n",
    "    initial_investment = 750000 - (10 * flat_rate) \n",
    "    \n",
    "    data_rows = [] #store data and concat to final dataframe at the end \n",
    "    #selected weightings structure\n",
    "    #first 3 riskiest at 20% ; 1 riskiest at 10% ; last 6 at 5%\n",
    "    weights = [0.20, 0.20, 0.20, 0.10, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]  \n",
    "    #final portfolio dataframe \n",
    "    Portfolio_Final = pd.DataFrame(columns=['Ticker', 'Price', 'Currency', 'Shares', 'Value', 'Weight'])\n",
    "\n",
    "    #iterates through the list of the ten ticker objects  \n",
    "    for i in range(len(ticker_objects)):\n",
    "        #determine the parameters for each ticker object \n",
    "        stock = ticker_objects[i] \n",
    "        hist = stock.history()\n",
    "        hist.index = pd.DatetimeIndex(hist.index).tz_localize(None, ambiguous='infer').tz_localize('UTC')\n",
    "        \n",
    "        \n",
    "        currency = stock.fast_info['currency'] # the currency, either USD and CAD \n",
    "        \n",
    "        \n",
    "        prices = hist['Close']\n",
    "        fast_info = stock.fast_info\n",
    "        symbol = stock.ticker #ticker symbol \n",
    "    \n",
    "        # Access the closing price on the specific date\n",
    "        if specific_date in hist.index and currency == 'CAD':\n",
    "            price = hist.loc[specific_date, 'Close']\n",
    "            #print(\"Closing price on {}: {}\".format(specific_date.date(), price))\n",
    "        \n",
    "        elif specific_date in hist.index and currency == 'USD':\n",
    "            #account for exchange rate \n",
    "            exchange_ticker = \"USDCAD=X\" \n",
    "            exchange_rate = yf.download(exchange_ticker, progress=False)\n",
    "            exchange_rate.index = pd.DatetimeIndex(exchange_rate.index).tz_localize(None, ambiguous='infer').tz_localize('UTC')\n",
    "            \n",
    "            price = hist.loc[specific_date, 'Close'] * exchange_rate.loc[specific_date, 'Close']\n",
    "\n",
    "            \n",
    "            \n",
    "        else:\n",
    "            print(\"No data available for {}\".format(specific_date.date()))\n",
    "\n",
    "        \n",
    "        weight = weights[i] # stored in the weightings data frame \n",
    "        value = initial_investment * weight # returns the money allocated to this stock (weight[i]) (total value of shares)\n",
    "        shares = value / price # value allocated divided by the close price on november 25th is the number of shares we can buy\n",
    "    \n",
    "        #create dictionary with the stock information \n",
    "        row_data = {\n",
    "            'Ticker': symbol, \n",
    "            'Price': price, \n",
    "            'Currency': currency, \n",
    "            'Shares': shares, \n",
    "            'Value': value, \n",
    "            'Weight': weight\n",
    "        }\n",
    "    \n",
    "        # Append the dictionary to the list\n",
    "        data_rows.append(row_data)\n",
    "   \n",
    "    #concant the list to the final portfolio dataframe \n",
    "    Portfolio_Final = pd.concat([Portfolio_Final, pd.DataFrame(data_rows)], ignore_index=True)\n",
    "    Portfolio_Final.index = Portfolio_Final.index + 1\n",
    "        \n",
    "    return Portfolio_Final \n",
    "\n",
    "Portfolio_Final = add_to_final_portfolio(final_stocks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 172,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'$750000.0'"
      ]
     },
     "execution_count": 172,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# This shows that the value of each stock we invest in + the initial transaction fee of 4.95 CAD per stock adds\n",
    "# up to our initial investment amount of 750,000 CAD.\n",
    "\n",
    "final_starting_value = f\"${round(Portfolio_Final['Value'].sum() + (10 * flat_rate), 9)}\"\n",
    "final_starting_value "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'100.0%'"
      ]
     },
     "execution_count": 173,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# This shows that the weight of each stock we invest adds up to the 100%\n",
    "\n",
    "final_weight = f\"{round(Portfolio_Final['Weight'].sum() * 100,10)}%\"\n",
    "final_weight "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 174,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "All values are in CAD\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Ticker</th>\n",
       "      <th>Price</th>\n",
       "      <th>Currency</th>\n",
       "      <th>Shares</th>\n",
       "      <th>Value</th>\n",
       "      <th>Weight</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>SHOP.TO</td>\n",
       "      <td>82.080002</td>\n",
       "      <td>CAD</td>\n",
       "      <td>1827.364725</td>\n",
       "      <td>149990.100</td>\n",
       "      <td>0.20</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>PYPL</td>\n",
       "      <td>76.172209</td>\n",
       "      <td>USD</td>\n",
       "      <td>1969.092159</td>\n",
       "      <td>149990.100</td>\n",
       "      <td>0.20</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>BMY</td>\n",
       "      <td>70.735290</td>\n",
       "      <td>USD</td>\n",
       "      <td>2120.442298</td>\n",
       "      <td>149990.100</td>\n",
       "      <td>0.20</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>QCOM</td>\n",
       "      <td>162.360521</td>\n",
       "      <td>USD</td>\n",
       "      <td>461.904467</td>\n",
       "      <td>74995.050</td>\n",
       "      <td>0.10</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>AXP</td>\n",
       "      <td>208.691935</td>\n",
       "      <td>USD</td>\n",
       "      <td>179.678841</td>\n",
       "      <td>37497.525</td>\n",
       "      <td>0.05</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>USB</td>\n",
       "      <td>47.507330</td>\n",
       "      <td>USD</td>\n",
       "      <td>789.299771</td>\n",
       "      <td>37497.525</td>\n",
       "      <td>0.05</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>BAC</td>\n",
       "      <td>38.210614</td>\n",
       "      <td>USD</td>\n",
       "      <td>981.337922</td>\n",
       "      <td>37497.525</td>\n",
       "      <td>0.05</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>BLK</td>\n",
       "      <td>891.613243</td>\n",
       "      <td>USD</td>\n",
       "      <td>42.055819</td>\n",
       "      <td>37497.525</td>\n",
       "      <td>0.05</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>CAT</td>\n",
       "      <td>330.808170</td>\n",
       "      <td>USD</td>\n",
       "      <td>113.351266</td>\n",
       "      <td>37497.525</td>\n",
       "      <td>0.05</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10</th>\n",
       "      <td>C</td>\n",
       "      <td>56.472021</td>\n",
       "      <td>USD</td>\n",
       "      <td>664.001824</td>\n",
       "      <td>37497.525</td>\n",
       "      <td>0.05</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "     Ticker       Price Currency       Shares       Value  Weight\n",
       "1   SHOP.TO   82.080002      CAD  1827.364725  149990.100    0.20\n",
       "2      PYPL   76.172209      USD  1969.092159  149990.100    0.20\n",
       "3       BMY   70.735290      USD  2120.442298  149990.100    0.20\n",
       "4      QCOM  162.360521      USD   461.904467   74995.050    0.10\n",
       "5       AXP  208.691935      USD   179.678841   37497.525    0.05\n",
       "6       USB   47.507330      USD   789.299771   37497.525    0.05\n",
       "7       BAC   38.210614      USD   981.337922   37497.525    0.05\n",
       "8       BLK  891.613243      USD    42.055819   37497.525    0.05\n",
       "9       CAT  330.808170      USD   113.351266   37497.525    0.05\n",
       "10        C   56.472021      USD   664.001824   37497.525    0.05"
      ]
     },
     "execution_count": 174,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"All values are in CAD\")\n",
    "Portfolio_Final"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 175,
   "metadata": {},
   "outputs": [],
   "source": [
    "Stocks_Final_data = {\n",
    "    'Ticker': Portfolio_Final['Ticker'],\n",
    "    'Shares': Portfolio_Final['Shares']\n",
    "}\n",
    "\n",
    "Stocks_Final = pd.DataFrame(Stocks_Final_data)\n",
    "Stocks_Final.to_csv('Stocks_Group_09.csv', encoding='utf-8', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Contribution Declaration\n",
    "\n",
    "The following team members made a meaningful contribution to this assignment:\n",
    "\n",
    "Neha Kamakshi Nicholas"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
